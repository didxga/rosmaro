{
    "docs": [
        {
            "location": "/", 
            "text": "Changes of behavior modeled as a graph\n\n\nRosmaro is a library that allows to model changes of behavior as a graph.\n\n\nEvery node represents some behavior and can \nfollow an arrow\n to a different node, and thus change the behavior of the model.\n\n\nA \ngraph\n is made of nodes.\n\n\nNodes may be:\n\n\n\n\nleaves\n (simple bags of functions)\n\n\nother \ngraphs\n\n\nfew other \nnodes composed together\n\n\nadapters\n (map the context and rename arrows leaving the adapted node)\n\n\n\n\nThe state of a Rosmaro model is serializable and stored using a compatible \nstorage mechanism\n.\n\n\nMethod calls may be synchronized using optional pessimistic \nlocks\n.\n\n\nA simple example - The Prince of Rosmaro\n\n\n\nconst rosmaro = require('rosmaro')\nconst storage = require('rosmaro-in-memory-storage@0.0.1')()\nconst lock = require('rosmaro-process-wide-lock0.0.1')()\n\n//That's a regular frog.\nconst frog = {\n  introduce_yourself() {\n    console.log(\"Ribbit! Ribbit!\")\n  }\n}\n\n//The Prince pays special attention to pizza.\nconst prince = {\n  introduce_yourself() {\n    console.log(\"I am The Prince of Rosmaro!\")\n  },\n  eat(dish) {\n    if (dish === \"pizza\") this.follow(\"ate_pizza\")\n  }\n}\n\n//An evil witch cast a spell on The Prince of Rosmaro.\n//Nothing bad happens unless he eats a pizza!\nconst cursed_prince_description = {\n  type: \"graph\",\n  start: \"prince\",\n  arrows: {\n    prince: { ate_pizza: \"frog\" }\n  },\n  nodes: { prince, frog }\n}\n\nconst cursed_prince = rosmaro(cursed_prince_description, storage, lock)\n\nawait cursed_prince.introduce_yourself() //I am The Prince of Rosmaro!\nawait cursed_prince.eat(\"yakisoba\")\nawait cursed_prince.introduce_yourself() //I am The Prince of Rosmaro!\nawait cursed_prince.eat(\"pizza\")\nawait cursed_prince.introduce_yourself() //Ribbit! Ribbit!\n\n\n\n\n\n\n\nFeel free to play around and simply type your code above!\n\n\nWhy is it interesting?\n\n\nThe frog is nothing but a frog. Knows just how to do the \nRibbit!\n sound.\n\n\nThe Prince can introduce himself and if you give him a pizza, he follows the path of the one who ate a pizza. That's all he does.\n\n\nThe model of the Cursed Prince connects the Prince and the frog with the \nate_pizza\n arrow.\n\n\nThis way the model of the frog, the model of the Prince and the model of the Cursed Prince stay separated.\n\n\nWould you like to change the Prince into a unicorn instead of a frog? Or maybe into an electric kettle? Feel free! Just model the unicorn or the kettle and change what the \nate_pizza\n arrow is pointing at! No need to change the Prince himself.\n\n\nRosmaro elsewhere\n\n\nIf you'd like to learn more about Rosmaro and the story behind it, please check the \nRosmaro elsewhere\n chapter.\n\n\nLicense\n\n\nRosmaro is licensed under the MIT license.", 
            "title": "What is Rosmaro"
        }, 
        {
            "location": "/#changes-of-behavior-modeled-as-a-graph", 
            "text": "Rosmaro is a library that allows to model changes of behavior as a graph.  Every node represents some behavior and can  follow an arrow  to a different node, and thus change the behavior of the model.  A  graph  is made of nodes.  Nodes may be:   leaves  (simple bags of functions)  other  graphs  few other  nodes composed together  adapters  (map the context and rename arrows leaving the adapted node)   The state of a Rosmaro model is serializable and stored using a compatible  storage mechanism .  Method calls may be synchronized using optional pessimistic  locks .", 
            "title": "Changes of behavior modeled as a graph"
        }, 
        {
            "location": "/#a-simple-example-the-prince-of-rosmaro", 
            "text": "const rosmaro = require('rosmaro')\nconst storage = require('rosmaro-in-memory-storage@0.0.1')()\nconst lock = require('rosmaro-process-wide-lock0.0.1')()\n\n//That's a regular frog.\nconst frog = {\n  introduce_yourself() {\n    console.log(\"Ribbit! Ribbit!\")\n  }\n}\n\n//The Prince pays special attention to pizza.\nconst prince = {\n  introduce_yourself() {\n    console.log(\"I am The Prince of Rosmaro!\")\n  },\n  eat(dish) {\n    if (dish === \"pizza\") this.follow(\"ate_pizza\")\n  }\n}\n\n//An evil witch cast a spell on The Prince of Rosmaro.\n//Nothing bad happens unless he eats a pizza!\nconst cursed_prince_description = {\n  type: \"graph\",\n  start: \"prince\",\n  arrows: {\n    prince: { ate_pizza: \"frog\" }\n  },\n  nodes: { prince, frog }\n}\n\nconst cursed_prince = rosmaro(cursed_prince_description, storage, lock)\n\nawait cursed_prince.introduce_yourself() //I am The Prince of Rosmaro!\nawait cursed_prince.eat(\"yakisoba\")\nawait cursed_prince.introduce_yourself() //I am The Prince of Rosmaro!\nawait cursed_prince.eat(\"pizza\")\nawait cursed_prince.introduce_yourself() //Ribbit! Ribbit!   Feel free to play around and simply type your code above!", 
            "title": "A simple example - The Prince of Rosmaro"
        }, 
        {
            "location": "/#why-is-it-interesting", 
            "text": "The frog is nothing but a frog. Knows just how to do the  Ribbit!  sound.  The Prince can introduce himself and if you give him a pizza, he follows the path of the one who ate a pizza. That's all he does.  The model of the Cursed Prince connects the Prince and the frog with the  ate_pizza  arrow.  This way the model of the frog, the model of the Prince and the model of the Cursed Prince stay separated.  Would you like to change the Prince into a unicorn instead of a frog? Or maybe into an electric kettle? Feel free! Just model the unicorn or the kettle and change what the  ate_pizza  arrow is pointing at! No need to change the Prince himself.", 
            "title": "Why is it interesting?"
        }, 
        {
            "location": "/#rosmaro-elsewhere", 
            "text": "If you'd like to learn more about Rosmaro and the story behind it, please check the  Rosmaro elsewhere  chapter.", 
            "title": "Rosmaro elsewhere"
        }, 
        {
            "location": "/#license", 
            "text": "Rosmaro is licensed under the MIT license.", 
            "title": "License"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Building a Rosmaro model\n\n\nRosmaro may be installed using npm:\n\n\n$ npm i rosmaro --save\n\n\n\n\nThis gives us access to the factory of rosmaro models:\n\n\nconst make_rosmaro_model = require('rosmaro')\n\n\n\n\nIt is a function with the following signature:\n\n\n(model_description, storage_mechanism, locking_mechanism) =\n model\n\n\n\n\nmodel_description\n is the description of the root node. It may be any of the supported \nbuilding blocks\n.\n\n\nstorage_mechanism\n is compatible with the \nspecification of storage mechanisms\n and somehow stores the state of the model. For a \nlist of recommended storage mechanisms\n check the table below.\n\n\nlocking_mechanism\n is compatible with the \nspecification of locking mechanisms\n and provides pessimistic locking. For a \nlist of recommended locking mechanisms\n check the table below.\n\n\nRecommended storage mechanisms\n\n\nHere's a list of recommended storage mechanisms:\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\nUrl\n\n\n\n\n\n\n\n\n\n\nrosmaro-in-memory-storage\n\n\nIn-memory storage.\n\n\ngithub.com/lukaszmakuch/rosmaro-in-memory-storage\n\n\n\n\n\n\nrosmaro-redis-storage\n\n\nUses Redis with the \nredis\n package.\n\n\ngithub.com/lukaszmakuch/rosmaro-redis-storage\n\n\n\n\n\n\n\n\nIf you know a compatible storage which is not mentioned above, let me know and I'll include it! :)\n\n\nRecommended locking mechanisms\n\n\nHere's a list of recommended locking mechanisms:\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\nUrl\n\n\n\n\n\n\n\n\n\n\nrosmaro-process-wide-lock\n\n\nProcess-wide, in-memory lock.\n\n\ngithub.com/lukaszmakuch/rosmaro-process-wide-lock\n\n\n\n\n\n\nrosmaro-redlock\n\n\nUses Redis with \nnode-redlock\n.\n\n\ngithub.com/lukaszmakuch/rosmaro-redlock\n\n\n\n\n\n\n\n\nIf you know a compatible locking mechanism which is not mentioned above, let me know and I'll include it! :)", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#building-a-rosmaro-model", 
            "text": "Rosmaro may be installed using npm:  $ npm i rosmaro --save  This gives us access to the factory of rosmaro models:  const make_rosmaro_model = require('rosmaro')  It is a function with the following signature:  (model_description, storage_mechanism, locking_mechanism) =  model  model_description  is the description of the root node. It may be any of the supported  building blocks .  storage_mechanism  is compatible with the  specification of storage mechanisms  and somehow stores the state of the model. For a  list of recommended storage mechanisms  check the table below.  locking_mechanism  is compatible with the  specification of locking mechanisms  and provides pessimistic locking. For a  list of recommended locking mechanisms  check the table below.", 
            "title": "Building a Rosmaro model"
        }, 
        {
            "location": "/getting-started/#recommended-storage-mechanisms", 
            "text": "Here's a list of recommended storage mechanisms:     Name  Description  Url      rosmaro-in-memory-storage  In-memory storage.  github.com/lukaszmakuch/rosmaro-in-memory-storage    rosmaro-redis-storage  Uses Redis with the  redis  package.  github.com/lukaszmakuch/rosmaro-redis-storage     If you know a compatible storage which is not mentioned above, let me know and I'll include it! :)", 
            "title": "Recommended storage mechanisms"
        }, 
        {
            "location": "/getting-started/#recommended-locking-mechanisms", 
            "text": "Here's a list of recommended locking mechanisms:     Name  Description  Url      rosmaro-process-wide-lock  Process-wide, in-memory lock.  github.com/lukaszmakuch/rosmaro-process-wide-lock    rosmaro-redlock  Uses Redis with  node-redlock .  github.com/lukaszmakuch/rosmaro-redlock     If you know a compatible locking mechanism which is not mentioned above, let me know and I'll include it! :)", 
            "title": "Recommended locking mechanisms"
        }, 
        {
            "location": "/building-blocks/leaves/", 
            "text": "Leaves are basic building blocks which are bags of functions. Every leaf may cause a \ntransition\n. It's also possible to add special functions which are executed when a leaf is entered or left (see below). Functions of leaves may \nreturn values\n which may be Promises. Every leaf has access to the context of the whole model. It can also read its own unique id.\n\n\nHere's an example of a leaf which uses all of its features:\n\n\nconst rich_leaf = {\n\n  unsynchronized: [\nfollow_your_path\n],\n\n  on_entry() {\n    console.log(`Entering the rich leaf.`)\n  },\n\n  follow_your_path() {\n    console.log(this.get_introduction())\n    const new_context = { ...this.context, new_value: 42 }\n    this.follow(\nmy_path\n, new_context)\n  },\n\n  before_leave() {\n    console.log(`Leaving the rich leaf.`)\n  },\n\n  after_leave() {\n    console.log(`The rich leaf has been left.`)\n  }\n\n  get_introduction() {\n    return `My id is ${this.id}.`\n  }\n\n}\n\n\n\n\nThe lack of the \ntype\n property indicates that this is a leaf.\n\n\nSpecial methods and properties\n\n\non_entry\n\n\nCalled when a transition to this leaf occurs. It has access to the id and the context. It may also cause a transition.\n\n\nbefore_leave\n\n\nCalled before the leaf is left. It occurs before the \non_entry\n method of the new leaf is called. It has access to the id and the context, but it cannot cause a transition.\n\n\nafter_leave\n\n\nCalled after the leaf is left. It occurs after the \non_entry\n method of the new leaf is called. It has access to the id and the context, but it cannot cause a transition.\n\n\nunsynchronized\n\n\nA list of methods that don't need to be synchronized using the locking mechanism. It may be ignored in case of composed leaves. For more details check the chapter on \nlocking\n.\n\n\nUnique ID\n\n\nEvery method of a leaf may read \nthis.id\n which is a unique ID of that leaf. It changes only when a transition from this leaf occurs. It changes even when it's a loop, that is a transition going from that leaf to the same leaf. It happens because even though the leaf may stay the same, a transition may set some different context, and thus the behavior of this leaf may differ. That's why a new ID is assigned.\n\n\nconst id_reader = {\n  read_id() {\n    return this.id\n  }\n}\n\n\n\n\nContext\n\n\nThe context is an immutable and serializable object shared among all leaves. It is available as the \nthis.context\n property. At the beginning, before any transition occurs, it's an empty object. It may be set during a transition.\n\n\nconst context_reader = {\n  read_context() {\n    return this.context\n  }\n}\n\nconst context_setter = {\n  set_new_context() {\n    this.follow(\nsome_arrow\n, new_context)\n  }\n}", 
            "title": "Leaves"
        }, 
        {
            "location": "/building-blocks/leaves/#special-methods-and-properties", 
            "text": "", 
            "title": "Special methods and properties"
        }, 
        {
            "location": "/building-blocks/leaves/#on_entry", 
            "text": "Called when a transition to this leaf occurs. It has access to the id and the context. It may also cause a transition.", 
            "title": "on_entry"
        }, 
        {
            "location": "/building-blocks/leaves/#before_leave", 
            "text": "Called before the leaf is left. It occurs before the  on_entry  method of the new leaf is called. It has access to the id and the context, but it cannot cause a transition.", 
            "title": "before_leave"
        }, 
        {
            "location": "/building-blocks/leaves/#after_leave", 
            "text": "Called after the leaf is left. It occurs after the  on_entry  method of the new leaf is called. It has access to the id and the context, but it cannot cause a transition.", 
            "title": "after_leave"
        }, 
        {
            "location": "/building-blocks/leaves/#unsynchronized", 
            "text": "A list of methods that don't need to be synchronized using the locking mechanism. It may be ignored in case of composed leaves. For more details check the chapter on  locking .", 
            "title": "unsynchronized"
        }, 
        {
            "location": "/building-blocks/leaves/#unique-id", 
            "text": "Every method of a leaf may read  this.id  which is a unique ID of that leaf. It changes only when a transition from this leaf occurs. It changes even when it's a loop, that is a transition going from that leaf to the same leaf. It happens because even though the leaf may stay the same, a transition may set some different context, and thus the behavior of this leaf may differ. That's why a new ID is assigned.  const id_reader = {\n  read_id() {\n    return this.id\n  }\n}", 
            "title": "Unique ID"
        }, 
        {
            "location": "/building-blocks/leaves/#context", 
            "text": "The context is an immutable and serializable object shared among all leaves. It is available as the  this.context  property. At the beginning, before any transition occurs, it's an empty object. It may be set during a transition.  const context_reader = {\n  read_context() {\n    return this.context\n  }\n}\n\nconst context_setter = {\n  set_new_context() {\n    this.follow( some_arrow , new_context)\n  }\n}", 
            "title": "Context"
        }, 
        {
            "location": "/building-blocks/graphs/", 
            "text": "Graph nodes are directed graphs connecting any number of nodes with arrows that may be followed by those nodes.\n\n\nThere's always one and only one current node of a graph. However, the current node may consist of a composite node. In such a scenario few nodes are used simultaneously, but they have a common parent which is always only one node of the graph.\n\n\nThe behavior of the whole graph is determined by the behavior of the current node. When a transition occurs and the current node changes, the behavior of the whole graph changes as well.\n\n\nThat's how does a simple graph definition look:\n\n\nconst box = {\n  type: \ngraph\n,\n  start: \nlocked\n,\n  arrows: {\n    locked: { hit_too_many_times: \nbroken\n }\n  },\n  nodes: { locked, broken }\n}\n\n\n\n\nThe \ntype\n property set to \ngraph\n indicates it's a graph.\nThe \nstart\n property determines which node is the initial node, that is which is active when the graph is used for the first time.\n\n\nArrows\n\n\nThe \narrows\n object allows to connect nodes included within the \nnodes\n object with arrows. In the above example if the node with the \nlocked\n key follows the arrow called \nhit_too_many_times\n, then a transition occurs and \nbroken\n is the new active node.\n\n\nMentioning nodes within the \narrows\n object is optional. That's why the \nbroken\n node is not mentioned.\n\n\nArrows definitions use \nshort names\n.\n\n\nOne node may sometimes follow different arrows. For example:\n\n\narrows: {\n  locked: {\n    hit_too_many_times: \nbroken\n,\n    still_fine: \nlocked\n\n  }\n}\n\n\n\n\nThere may be actions associated with arrows:\n\n\narrows: {\n  locked: {\n    hit_too_many_times: [scream, say_things_may_be_taken, \nbroken\n, say_it_hurt],\n    still_fine: [say_you_will_never_open_me, \nlocked\n]\n  }\n}\n\n\n\n\nEvery transition action may return a Promise. Transition actions are executed sequentially. The action called \nsay_things_may_be_taken\n won't run unless \nscream\n is finished. Both \nscream\n and \nsay_things_may_be_taken\n are actions executed before the transition to the \nbroken\n node, while the action called \nsay_it_hurt\n will be executed after the transition. They don't have access to the context.\n\n\nA transition action is just a function that takes no arguments and may return a Promise:\n\n\nconst some_action = async function () { /* ... */ }\nconst simple_action =  function () { /* ... */ }", 
            "title": "Graphs"
        }, 
        {
            "location": "/building-blocks/graphs/#arrows", 
            "text": "The  arrows  object allows to connect nodes included within the  nodes  object with arrows. In the above example if the node with the  locked  key follows the arrow called  hit_too_many_times , then a transition occurs and  broken  is the new active node.  Mentioning nodes within the  arrows  object is optional. That's why the  broken  node is not mentioned.  Arrows definitions use  short names .  One node may sometimes follow different arrows. For example:  arrows: {\n  locked: {\n    hit_too_many_times:  broken ,\n    still_fine:  locked \n  }\n}  There may be actions associated with arrows:  arrows: {\n  locked: {\n    hit_too_many_times: [scream, say_things_may_be_taken,  broken , say_it_hurt],\n    still_fine: [say_you_will_never_open_me,  locked ]\n  }\n}  Every transition action may return a Promise. Transition actions are executed sequentially. The action called  say_things_may_be_taken  won't run unless  scream  is finished. Both  scream  and  say_things_may_be_taken  are actions executed before the transition to the  broken  node, while the action called  say_it_hurt  will be executed after the transition. They don't have access to the context.  A transition action is just a function that takes no arguments and may return a Promise:  const some_action = async function () { /* ... */ }\nconst simple_action =  function () { /* ... */ }", 
            "title": "Arrows"
        }, 
        {
            "location": "/building-blocks/composites/", 
            "text": "Composites are the way to use many different nodes as they were one. A method call applies to all the composed nodes. Composed nodes are called in the same order as they appear on the list.\n\n\nThe format of a composite:\n\n\nconst article = {\n  type: \ncomposite\n,\n  nodes: [\n    [\nheader\n, header_definition],\n    [\nbody\n, body_definition],\n    [\nfooter\n, footer_definition]\n  ]\n}\n\n\n\n\nA very important part is the \ntype\n property which in case of composites must equal \ncomposite\n. In the above example there are three composed nodes. The first element of each of those three arrays is the name of a composed node, and the second one is its definition.\n\n\nWhat happens to the context?\n\n\nIf few nodes of a composite node requested a transition, they all provided some context.\nWe could start with the following context:\n\n\n{ a: 10, b: 20 }\n\n\n\n\nThen one of the composed nodes performs a transition with a slightly modified version of this context:\n\n\n{ a: 10, b: 40 }\n\n\n\n\nAnother composed node also requested a transition and modified the original context in the following way:\n\n\n{ a: 11, b: 20 }\n\n\n\n\nThe final context will be the result of merging all the differences between the initial context and provided contexts into the initial context:\n\n\n{ a: 11, b: 40 }", 
            "title": "Composites"
        }, 
        {
            "location": "/building-blocks/composites/#what-happens-to-the-context", 
            "text": "If few nodes of a composite node requested a transition, they all provided some context.\nWe could start with the following context:  { a: 10, b: 20 }  Then one of the composed nodes performs a transition with a slightly modified version of this context:  { a: 10, b: 40 }  Another composed node also requested a transition and modified the original context in the following way:  { a: 11, b: 20 }  The final context will be the result of merging all the differences between the initial context and provided contexts into the initial context:  { a: 11, b: 40 }", 
            "title": "What happens to the context?"
        }, 
        {
            "location": "/building-blocks/adapters/", 
            "text": "An adapter is a kind of a wrapper for another node. It provides methods to translate the context for the adapted node as well as rename all the arrows that leave the adapted node.\n\n\nLet's think of a situation when we want to re-use some node, but it doesn't exactly fit our model. It expects the context to look like this:\n\n\n{ number: 42 }\n\n\n\n\nWhile the rest of our model works with the following format:\n\n\n{ value: 42 }\n\n\n\n\nWe also expect that the node is going to follow an arrow named \nfound\n, while the incompatible node actually follows an arrow named \ndiscovered\n.\nSituations like that are very common. The good thing is that adapters address this problem:\n\n\nconst adapted = {\n  type: \nadapter\n,\n  map_entering_context(ctx) {\n    return { number: ctx.value }\n  },\n  map_leaving_context(ctx) {\n    return { value: ctx.number }\n  },\n  rename_leaving_arrows: {\n    discovered: \nfound\n\n  },\n  adapted: incompatible\n}\n\n\n\n\nA very important part is the \ntype\n property which in case of adapters must equal \nadapter\n.", 
            "title": "Adapters"
        }, 
        {
            "location": "/transitions/correct/", 
            "text": "This chapter describes types of allowed transitions.\n\n\nTo another node of a graph\n\n\n\n\nThis is the simplest transition. If the current node is \nA\n, then following the \nx\n arrow will set it to \nB\n.\n\n\nThis is what the code looks like:\n\n\n{\n  type: \ngraph\n,\n  start: \nA\n,\n  arrows: {\n    A: { x: \nB\n }\n  },\n  nodes: { A, B }\n}\n\n\n\n\nTo a node on a higher level\n\n\n\n\nLet's forget for a moment about everything around the \nA\n graph and focus just on that graph. It looks very similar to the case mentioned in the previous example - \nTo another node of a graph\n. If the \nA:A\n node follows the \nx\n arrow, it goes to the \nA:B\n node.\n\n\nBut what happens if the \nA:B\n node follows the \nx\n arrow? Within the \nA\n graph the \nx\n arrow going from the \nA:B\n node is not connected to any other node. An arrow like that leaves the parent of the node that follows it. That's why on the diagram there's an arrow to the border of the \nA\n graph. From the point of view of the \n(root)\n graph it is the \nA\n node that follows the \nx\n arrow.\n\n\nSo following the \nx\n arrow by the \nA:B\n sets the current node to \nB\n.\n\n\nAfter the \nA\n graph is left by following an arrow by the \nA:B\n node, the \nA:B\n node becomes its new entry node. So if we follow an arrow to the \nA\n node, it will go into the \nA:B\n node, even if previously the initial node was the \nA:A\n node.\n\n\nSimultaneous transitions on different levels\n\n\n\n\nHere we have a composite \nB\n, so both \nB:A\n and \nB:B\n nodes are active at the same time. If we are currently in nodes \nB:A\n, \nB:B:A\n, then following the \nx\n arrow sets the current node to \nA\n. Even though \nB\n is not active anymore, a regular transition from \nB:B:A\n to \nB:B:A\n took place. It means all the node and transition actions were executed. Entering the \nB\n node again will mean entering nodes \nB:A\n, \nB:B:B\n.\n\n\nLeaving one node to few nodes on different levels\n\n\n\n\nBecause nodes \nB:B:A\n and \nB:B:B\n are active in the same time, they may both follow two different arrows. From the perspective of the \nB\n graph it looks like the \nB:B\n node is following two different arrows simultaneously.\n\n\nEven though it may look weird, there's no need to panic. Everything is fine, because it's not a situation when two nodes of the same graph are entered.\n\n\nFollowing the \nx\n arrow will leave the \nB:B\n node and set the current node of the \nB\n graph to \nB:A\n and following the \ny\n arrow will leave the whole \nB\n graph and set the current node of the \n(root)\n graph to \nA\n.\n\n\nSo the result node is \nA\n and entering \nB\n will actually enter \nB:A\n.\n\n\nTransitions among left nodes\n\n\n\n\nLet's assume the current nodes of the model are \nB:A\n, \nB:B:A\n. All the \ne\n arrows are the arrows automatically followed by the \non_entry\n methods as soon as the node is entered.\n\n\nSo following the \nx\n arrow will change the current nodes from \nB:A\n, \nB:B:A\n to \nB:A\n, \nB:B:D\n. In the meantime \nB:A\n, \nB:B:A\n, \nB:B:B\n, \nB:B:C\n and \nA\n will be left. Bear in mind it's not going to be the same \nB:A\n node anymore. It will have another \nID\n, because the previous one has been left.", 
            "title": "Correct"
        }, 
        {
            "location": "/transitions/correct/#to-another-node-of-a-graph", 
            "text": "This is the simplest transition. If the current node is  A , then following the  x  arrow will set it to  B .  This is what the code looks like:  {\n  type:  graph ,\n  start:  A ,\n  arrows: {\n    A: { x:  B  }\n  },\n  nodes: { A, B }\n}", 
            "title": "To another node of a graph"
        }, 
        {
            "location": "/transitions/correct/#to-a-node-on-a-higher-level", 
            "text": "Let's forget for a moment about everything around the  A  graph and focus just on that graph. It looks very similar to the case mentioned in the previous example -  To another node of a graph . If the  A:A  node follows the  x  arrow, it goes to the  A:B  node.  But what happens if the  A:B  node follows the  x  arrow? Within the  A  graph the  x  arrow going from the  A:B  node is not connected to any other node. An arrow like that leaves the parent of the node that follows it. That's why on the diagram there's an arrow to the border of the  A  graph. From the point of view of the  (root)  graph it is the  A  node that follows the  x  arrow.  So following the  x  arrow by the  A:B  sets the current node to  B .  After the  A  graph is left by following an arrow by the  A:B  node, the  A:B  node becomes its new entry node. So if we follow an arrow to the  A  node, it will go into the  A:B  node, even if previously the initial node was the  A:A  node.", 
            "title": "To a node on a higher level"
        }, 
        {
            "location": "/transitions/correct/#simultaneous-transitions-on-different-levels", 
            "text": "Here we have a composite  B , so both  B:A  and  B:B  nodes are active at the same time. If we are currently in nodes  B:A ,  B:B:A , then following the  x  arrow sets the current node to  A . Even though  B  is not active anymore, a regular transition from  B:B:A  to  B:B:A  took place. It means all the node and transition actions were executed. Entering the  B  node again will mean entering nodes  B:A ,  B:B:B .", 
            "title": "Simultaneous transitions on different levels"
        }, 
        {
            "location": "/transitions/correct/#leaving-one-node-to-few-nodes-on-different-levels", 
            "text": "Because nodes  B:B:A  and  B:B:B  are active in the same time, they may both follow two different arrows. From the perspective of the  B  graph it looks like the  B:B  node is following two different arrows simultaneously.  Even though it may look weird, there's no need to panic. Everything is fine, because it's not a situation when two nodes of the same graph are entered.  Following the  x  arrow will leave the  B:B  node and set the current node of the  B  graph to  B:A  and following the  y  arrow will leave the whole  B  graph and set the current node of the  (root)  graph to  A .  So the result node is  A  and entering  B  will actually enter  B:A .", 
            "title": "Leaving one node to few nodes on different levels"
        }, 
        {
            "location": "/transitions/correct/#transitions-among-left-nodes", 
            "text": "Let's assume the current nodes of the model are  B:A ,  B:B:A . All the  e  arrows are the arrows automatically followed by the  on_entry  methods as soon as the node is entered.  So following the  x  arrow will change the current nodes from  B:A ,  B:B:A  to  B:A ,  B:B:D . In the meantime  B:A ,  B:B:A ,  B:B:B ,  B:B:C  and  A  will be left. Bear in mind it's not going to be the same  B:A  node anymore. It will have another  ID , because the previous one has been left.", 
            "title": "Transitions among left nodes"
        }, 
        {
            "location": "/transitions/incorrect/", 
            "text": "This chapter contains examples of incorrect or impossible transitions.\n\n\nTransition to a node on a lower level\n\n\n\n\nIn order to keep nodes more decoupled, transitions to a node on a lower level are not allowed. An arrow may be pointing \nfrom a node to its sibling\n or leave the parent graph what makes the \nparent follow that arrow\n.\n\n\nEntering different nodes of the same graph\n\n\n\n\nIt is possible to the \nC\n node to follow both \nx\n and \ny\n arrows in the same time. That could be totally \nvalid in some cases\n, but in this case it violates the rule of \ngraphs\n saying that there may be only one current node.", 
            "title": "Incorrect"
        }, 
        {
            "location": "/transitions/incorrect/#transition-to-a-node-on-a-lower-level", 
            "text": "In order to keep nodes more decoupled, transitions to a node on a lower level are not allowed. An arrow may be pointing  from a node to its sibling  or leave the parent graph what makes the  parent follow that arrow .", 
            "title": "Transition to a node on a lower level"
        }, 
        {
            "location": "/transitions/incorrect/#entering-different-nodes-of-the-same-graph", 
            "text": "It is possible to the  C  node to follow both  x  and  y  arrows in the same time. That could be totally  valid in some cases , but in this case it violates the rule of  graphs  saying that there may be only one current node.", 
            "title": "Entering different nodes of the same graph"
        }, 
        {
            "location": "/working-with-rosmaro/names-of-nodes/", 
            "text": "This chapter covers both types of names of Rosmaro nodes.\n\n\nShort names used in the context of a single node\n\n\nLeaves\n\n\nLeaves don't specify any names.\n\n\nNodes of a graph\n\n\nconst graph = {\n  type: \ngraph\n,\n  start: \nA\n,\n  arrows: {},\n  nodes: { A: any_node_definition, B: any_node_definition }\n}\n\n\n\n\nIn the above example there are two nodes called \nA\n and \nB\n.\n\n\nNodes of a composite\n\n\nconst composite = {\n  type: \ncomposite\n,\n  nodes: [\n    [\nA\n, any_node_definition],\n    [\nB\n, any_node_definition]\n  ]\n}\n\n\n\n\nThis composite consist of two nodes: \nA\n and \nB\n. Bear in mind how are they defined. It's not an object, but an array. Also order of elements matters - the name goes first, then the definition.\n\n\nAdapted node\n\n\nconst adapter = {\n  type: \nadapter\n,\n  adapted: any_node_definition\n}\n\n\n\n\nThe adapted node is always called \nadapted\n.\n\n\nFull names used by the whole model\n\n\nFull names of nodes are names given them by their parents together with full names of those parents glued with the \n:\n symbol.\n\n\nNested graphs\n\n\n\n//named \nC\n by its parent \nB\n what gives \nB:C\n\nconst C = {}\n\n//named \nB\n by its parent\nconst B = {\n  type: \ngraph\n,\n  start: \nC\n,\n  arrows: {},\n  nodes: { C }\n}\n\n//\n (root)\nconst A = {\n  type: \ngraph\n,\n  start: \nB\n,\n  arrows: {},\n  nodes: { B }\n}\n\n\n\n\nHere we can see one leaf \nC\n. Its parent is \nB\n and the parent of \nB\n is \nA\n. But \nA\n has no parent so it has no name. That's why the full name of \nC\n is \nB:C\n.\n\n\nNamed composites\n\n\nIf we put a composite with two leaves into any node that may name it, like another composite, graph or adapter, we get two full names with a common parent:\n\n\nconst D = {}\n\nconst C = {}\n\nconst B = {\n  type: \ncomposite\n,\n  nodes: [\n    [\nC\n, C],\n    [\nD\n, D]\n  ]\n}\n\n//A is the root\nconst A = {\n  type: \nadapter\n,\n  adapted: B\n}\n\n\n\n\nThe leaves are: \nadapted:C\n, \nadapted:D\n.", 
            "title": "Names of nodes"
        }, 
        {
            "location": "/working-with-rosmaro/names-of-nodes/#short-names-used-in-the-context-of-a-single-node", 
            "text": "", 
            "title": "Short names used in the context of a single node"
        }, 
        {
            "location": "/working-with-rosmaro/names-of-nodes/#leaves", 
            "text": "Leaves don't specify any names.", 
            "title": "Leaves"
        }, 
        {
            "location": "/working-with-rosmaro/names-of-nodes/#nodes-of-a-graph", 
            "text": "const graph = {\n  type:  graph ,\n  start:  A ,\n  arrows: {},\n  nodes: { A: any_node_definition, B: any_node_definition }\n}  In the above example there are two nodes called  A  and  B .", 
            "title": "Nodes of a graph"
        }, 
        {
            "location": "/working-with-rosmaro/names-of-nodes/#nodes-of-a-composite", 
            "text": "const composite = {\n  type:  composite ,\n  nodes: [\n    [ A , any_node_definition],\n    [ B , any_node_definition]\n  ]\n}  This composite consist of two nodes:  A  and  B . Bear in mind how are they defined. It's not an object, but an array. Also order of elements matters - the name goes first, then the definition.", 
            "title": "Nodes of a composite"
        }, 
        {
            "location": "/working-with-rosmaro/names-of-nodes/#adapted-node", 
            "text": "const adapter = {\n  type:  adapter ,\n  adapted: any_node_definition\n}  The adapted node is always called  adapted .", 
            "title": "Adapted node"
        }, 
        {
            "location": "/working-with-rosmaro/names-of-nodes/#full-names-used-by-the-whole-model", 
            "text": "Full names of nodes are names given them by their parents together with full names of those parents glued with the  :  symbol.", 
            "title": "Full names used by the whole model"
        }, 
        {
            "location": "/working-with-rosmaro/names-of-nodes/#nested-graphs", 
            "text": "//named  C  by its parent  B  what gives  B:C \nconst C = {}\n\n//named  B  by its parent\nconst B = {\n  type:  graph ,\n  start:  C ,\n  arrows: {},\n  nodes: { C }\n}\n\n//  (root)\nconst A = {\n  type:  graph ,\n  start:  B ,\n  arrows: {},\n  nodes: { B }\n}  Here we can see one leaf  C . Its parent is  B  and the parent of  B  is  A . But  A  has no parent so it has no name. That's why the full name of  C  is  B:C .", 
            "title": "Nested graphs"
        }, 
        {
            "location": "/working-with-rosmaro/names-of-nodes/#named-composites", 
            "text": "If we put a composite with two leaves into any node that may name it, like another composite, graph or adapter, we get two full names with a common parent:  const D = {}\n\nconst C = {}\n\nconst B = {\n  type:  composite ,\n  nodes: [\n    [ C , C],\n    [ D , D]\n  ]\n}\n\n//A is the root\nconst A = {\n  type:  adapter ,\n  adapted: B\n}  The leaves are:  adapted:C ,  adapted:D .", 
            "title": "Named composites"
        }, 
        {
            "location": "/working-with-rosmaro/returning-values/", 
            "text": "Let's assume that we have a Rosmaro model built with the following leaf.\n\n\nconst the_one_who_knows = {\n  give_me_the_answer() {\n    return 42\n  }\n}\n\n\n\n\nThe Rosmaro model will always return a Promise, even if the called method doesn't return a Promise. That's why we always need to wait for the result.\n\n\nconst the_result = await model.give_me_the_answer()\n\n\n\n\nThe awaited result is always an object with keys named after \nfull names of nodes\n. In the above case it could look like this:\n\n\n{\n  \nthey:the_one_who_knows\n: 42,\n  \nthey:the_one_who_sees_nothing\n: undefined\n}\n\n\n\n\nThere are many returned values when \ncomposite nodes\n are used to build the model. Regardless the number of current nodes, the result always follows that format. So even if there would be just one active node, it would still look like this:\n\n\n{\n  \nthey:the_one_who_knows\n: 42\n}", 
            "title": "Returning values"
        }, 
        {
            "location": "/working-with-rosmaro/locking/", 
            "text": "Synchronization\n\n\nEvery method call is synchronized by default. It means that if we execute the following code:\n\n\n//counter is a Rosmaro model\ncounter.incr()\ncounter.incr()\n\n\n\n\nthe second \nincr\n will start executing only after the first \nincr\n returns. So even if the \nincr\n method is asynchronous, the counter will always be incremented twice.\n\n\nTurning synchronization off\n\n\nSometimes it's safe to run a method without synchronization. In a situation like that we can use the \nunsynchronized\n parameter of a \nleaf\n.\n\n\nThe lock is acquired anyways to read the state of the model and determine whether the call should be synchronized, but as soon as the method call is found unsynchronized, the lock is released. It may provide a significant performance boost in case of long running methods called simultaneously.\n\n\nIf there are few active nodes due to usage of a \ncomposite node\n, all the unsynchronized methods must be marked as \nunsynchronized\n. If there are two nodes: \nA\n and \nB\n, both have a \ndo_it\n method but just \nA\n defines it as \nunsynchronized\n, then the call to the \ndo_it\n method of the Rosmaro model will be synchronized.\n\n\nWhat if a method call crashes?\n\n\nWhen a method call crashes, the lock is released.", 
            "title": "Locking"
        }, 
        {
            "location": "/working-with-rosmaro/locking/#synchronization", 
            "text": "Every method call is synchronized by default. It means that if we execute the following code:  //counter is a Rosmaro model\ncounter.incr()\ncounter.incr()  the second  incr  will start executing only after the first  incr  returns. So even if the  incr  method is asynchronous, the counter will always be incremented twice.", 
            "title": "Synchronization"
        }, 
        {
            "location": "/working-with-rosmaro/locking/#turning-synchronization-off", 
            "text": "Sometimes it's safe to run a method without synchronization. In a situation like that we can use the  unsynchronized  parameter of a  leaf .  The lock is acquired anyways to read the state of the model and determine whether the call should be synchronized, but as soon as the method call is found unsynchronized, the lock is released. It may provide a significant performance boost in case of long running methods called simultaneously.  If there are few active nodes due to usage of a  composite node , all the unsynchronized methods must be marked as  unsynchronized . If there are two nodes:  A  and  B , both have a  do_it  method but just  A  defines it as  unsynchronized , then the call to the  do_it  method of the Rosmaro model will be synchronized.", 
            "title": "Turning synchronization off"
        }, 
        {
            "location": "/working-with-rosmaro/locking/#what-if-a-method-call-crashes", 
            "text": "When a method call crashes, the lock is released.", 
            "title": "What if a method call crashes?"
        }, 
        {
            "location": "/contribution/storage-specification/", 
            "text": "Interface\n\n\nThe storage mechanism has the following interface:\n\n\n{\n  async get_data() {},\n  async set_data(new_state) {},\n  async remove_data() {}\n}\n\n\n\n\nget_data()\n\n\nReturns a Promise that resolves to an object equal to the one previously set using the \nset_data\n method. If nothing has been set yet or the \nremove_data\n method has been called, it returns a nullify value.\n\n\nset_data(new_state)\n\n\nTakes a serializable object representing the state of a Rosmaro model and returns a Promise which when resolved indicates the data has been saved.\n\n\nremove_data\n\n\nReturns a Promise which when resolved indicates all the data of that model has been removed.\n\n\nErrors\n\n\nEvery method of a storage may throw an error. It is important that those errors \nare Error objects\n. Throwing something else, like a string, may cause a crash.", 
            "title": "Storage specification"
        }, 
        {
            "location": "/contribution/storage-specification/#interface", 
            "text": "The storage mechanism has the following interface:  {\n  async get_data() {},\n  async set_data(new_state) {},\n  async remove_data() {}\n}", 
            "title": "Interface"
        }, 
        {
            "location": "/contribution/storage-specification/#get_data", 
            "text": "Returns a Promise that resolves to an object equal to the one previously set using the  set_data  method. If nothing has been set yet or the  remove_data  method has been called, it returns a nullify value.", 
            "title": "get_data()"
        }, 
        {
            "location": "/contribution/storage-specification/#set_datanew_state", 
            "text": "Takes a serializable object representing the state of a Rosmaro model and returns a Promise which when resolved indicates the data has been saved.", 
            "title": "set_data(new_state)"
        }, 
        {
            "location": "/contribution/storage-specification/#remove_data", 
            "text": "Returns a Promise which when resolved indicates all the data of that model has been removed.", 
            "title": "remove_data"
        }, 
        {
            "location": "/contribution/storage-specification/#errors", 
            "text": "Every method of a storage may throw an error. It is important that those errors  are Error objects . Throwing something else, like a string, may cause a crash.", 
            "title": "Errors"
        }, 
        {
            "location": "/contribution/locks-specification/", 
            "text": "Signature\n\n\nThe locking mechanism used by Rosmaro has the following signature:\n\n\nlock = async () =\n unlock\n\n\n\n\nCalling the \nlock\n function acquires a pessimistic lock. It takes no arguments and returns a Promise that resolves to the \nunlock\n function. Calling the \nunlock\n function returns a Promise which if resolved indicates that the previously acquired lock has been released.\n\n\nErrors\n\n\nBoth \nlock\n and \nunlock\n may throw errors. It's very important those errors \nare Error objects\n. Throwing something else may cause a crash.", 
            "title": "Locks specification"
        }, 
        {
            "location": "/contribution/locks-specification/#signature", 
            "text": "The locking mechanism used by Rosmaro has the following signature:  lock = async () =  unlock  Calling the  lock  function acquires a pessimistic lock. It takes no arguments and returns a Promise that resolves to the  unlock  function. Calling the  unlock  function returns a Promise which if resolved indicates that the previously acquired lock has been released.", 
            "title": "Signature"
        }, 
        {
            "location": "/contribution/locks-specification/#errors", 
            "text": "Both  lock  and  unlock  may throw errors. It's very important those errors  are Error objects . Throwing something else may cause a crash.", 
            "title": "Errors"
        }, 
        {
            "location": "/elsewhere/", 
            "text": "Below is a list of materials somehow related to Rosmaro.\n\n\n\n\nState machines to the rescue of complex forms\n - a blog post about building a wizard with Rosmaro\n\n\nAn example wizard implemented using Rosmaro\n - the source code of the application described in the post above\n\n\nDecomposing wizards with Rosmaro\n - a video similar to the post above, showing a wizard build with Rosmaro\n\n\nBalancing IF statements and nodes with Rosmaro\n - a video on finding the optimal number of if statements\n\n\n\n\nDo you know something that should be mentioned above? Let me know and I'll include it! :)", 
            "title": "Rosmaro elsewhere"
        }
    ]
}