<!doctype html>
<html>
<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width">

  <title>Rosmaro - visual automata-based programming</title>

  <!-- highlighter -->
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script> 

  <!-- Flatdoc -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script src='https://cdn.rawgit.com/rstacruz/flatdoc/v0.9.0/legacy.js'></script>
  <script src='https://cdn.rawgit.com/rstacruz/flatdoc/v0.9.0/flatdoc.js'></script>

  <!-- Flatdoc theme -->
  <link  href='https://cdn.rawgit.com/rstacruz/flatdoc/v0.9.0/theme-white/style.css' rel='stylesheet'>
  <script src='https://cdn.rawgit.com/rstacruz/flatdoc/v0.9.0/theme-white/script.js'></script>

  <!-- custom css -->
  <link  href='style.css' rel='stylesheet'>

  <!-- Meta -->
  <meta content="Rosmaro" property="og:title">
  <meta content="A visual automata-based programming library for JavaScript." name="description">

  <!-- Initializer -->
  <script>
    Flatdoc.run({
      fetcher: function (callback) {
        callback(null, document.getElementById('doc').innerHTML)
      },
      highlight: function (code, value) {
        return code;
      }
    });
    $(document).on('flatdoc:ready', function() {
      hljs.initHighlightingOnLoad();
    });
  </script>


  <script id="doc" type="text/markdown" src="index.html">
# Rosmaro 101

## What is Rosmaro

Rosmaro is a visual automata-based programming library for JavaScript. 

It allows to build stateful objects - _Rosmaro models_. They keep data-related state in a dictionary structure and express behavior-related state using a state machine.

If you wish, you can think of Rosmaro using one of the following metaphors:

- An event-based routing for methods
- An object where _this_ is a state machine 
- A flavor of state diagrams brought to life

## What makes Rosmaro interesting

There are at least few reasons why Rosmaro may be interesting:

- Reduced number of error-prone conditional statements achieved by replacing many boolean flags with a graph.
- Programing using a human-friendly, declarative visual language that says _what_ should happen and not _how_ should it happen. 
- Code decoupling - any particular handler has a constant behavior that never changes and is not directly connected to any other handler.

## Example

Building a _Rosmaro model_ consists of two steps: 

1. Drawing a state machine graph that describes changes of behavior
1. Coding handlers - pieces of behavior associated with graph nodes

Let's build a model of a cursed prince, who turns into a frog after eating a pizza.

Although we could write a JSON file describing the graph by hand, it's a lot more fun to use the [Rosmaro Editor](https://rosmaro.js.org/editor).

![model graph](img/example-graph.png "A cursed prince")

After drawing the graph visible above, __the following JSON is generated automatically__.
```json
{
  "main": {
    "type": "graph",
    "nodes": {
      "Prince": "Prince",
      "Frog": "Frog"
    },
    "arrows": {
      "Prince": {
        "ate pizza": {
          "target": "Frog",
          "entryPoint": "start"
        }
      }
    },
    "entryPoints": {
      "start": {
        "target": "Prince",
        "entryPoint": "start"
      }
    }
  },
  "Prince": {
    "type": "leaf"
  },
  "Frog": {
    "type": "leaf"
  }
}
```

The graph tells the story of how does the model change over time and what makes it change. At the beginning it behaves like a _Prince_. That's what the arrow from the _start_ entry point pointing at the _Prince_ node is telling us. Then, as soon as the _Prince_ eats a pizza, he follows the arrow called _ate pizza_. The model is not anymore in the _Prince_ state, but in the _Frog_ state.

Now it's the time to code different behaviors.

This is the behavior of the _Frog_:
```javascript
const Frog = {
  introduceYourself: () => "Ribbit! Ribbit!"
};
```

It answers to only one method call - _introduceYourself_. Every single time when it's asked to introduce itself, it makes the _Ribbit!_ sound.

This is the behavior of the _Prince_:
```javascript
const Prince = {
  introduceYourself: () => "I am The Prince of Rosmaro!",
  eat: ({dish}) => {
    if (dish === 'pizza') return {arrow: 'ate pizza'};
  }
};
```

Every time he introduce himself, he says _I am The Prince of Rosmaro!_. When he eats a pizza, he follows the _ate pizza_ arrow.

Let's put it all together.
```javascript
import makeStorage from 'rosmaro-in-memory-storage';
import makeLock from 'rosmaro-process-wide-lock';
import rosmaro from 'rosmaro';
import graph from './graph.json'; // The generated graph

const Frog = {
  introduceYourself: () => "Ribbit! Ribbit!"
};

const Prince = {
  introduceYourself: () => "I am The Prince of Rosmaro!",
  eat: ({dish}) => {
    if (dish === 'pizza') return {arrow: 'ate pizza'};
  }
};

const model = rosmaro({
  graph,
  handlers: {Prince, Frog},
  storage: makeStorage(),
  lock: makeLock()
});
```

In order to obtain a working model, we need to provide at least 4 parts:

- the state machine graph (generated based on the drawn graph)
- handlers (code representing different behaviors)
- a storage (for example, from the [rosmaro-in-memory-storage](https://github.com/lukaszmakuch/rosmaro-in-memory-storage) package)
- a lock (for example, from the [rosmaro-process-wide-lock](https://github.com/lukaszmakuch/rosmaro-process-wide-lock) package)

The model works like expected:
```javascript
> model.introduceYourself();
'I am The Prince of Rosmaro!'

> model.eat({dish: 'yakisoba'});
undefined

> model.introduceYourself();
'I am The Prince of Rosmaro!'

> model.eat({dish: 'pizza'});
undefined

> model.introduceYourself();
'Ribbit! Ribbit!'
```

## License
Rosmaro is licensed under the MIT license.

## Integrations

Below is a list of utilities useful when using Rosmaro together with other libraries.

- [Rosmaro-React](https://github.com/lukaszmakuch/rosmaro-react) for building React user interfaces

## Rosmaro elsewhere
- [React and visual automata-based programming](https://medium.com/dailyjs/react-and-visual-automata-based-programming-c1d13e153cde) - an article about building a wizard using Rosmaro and React

# Graphs

## Introduction

The graph is the most outer layer of a _Rosmaro model_. It is meant to represent all of the possible changes of behavior. 

There are four types of nodes:

- leaves
- composites
- dynamic composites
- graphs

The model graph is represented by a collection of nodes, where each node has a unique name. The root node of the model graph is __the _main_ node, which is mandatory__. It may be of any of the supported node types, even a leaf.

Let's take a look at [the example graph](#rosmaro-101-example) one more time. It's a collection of three nodes:

- a graph called _main_
- a leaf called _Prince_
- a leaf called _Frog_

What's important and what's going to be explained in details later in this chapter, is that local names of nodes of a graph are not directly connected to any node. It means that the _Prince_ local node within the _main_ graph could be renamed to _Human_ and still be linked to the _Prince_ node.

The structure used to build the model graph looks like this:

1. Node A
  1. Local node A (underlaying node: Node B)
  1. Local node B (underlaying node: Node C)
1. Node B
1. Node C
  1. Local node A (underlaying node: Node D)
1. Node D

## The Rosmaro Editor

The recommended way of drawing a graph is using the [Rosmaro Editor](https://rosmaro.js.org/editor). To get started you don't need to install anything, as it is available on-line. A new graph may be created, or an existing JSON file may be imported.

However, if you only want, you cen actually code parts of the graph or even the whole graph, as the JSON file generated by the editor is meant to be human-readable.

## Leaves

Leaves are the basic nodes. They have no children. All they have is a name, so they can be used as underlaying nodes for children of [graphs](#graphs-leaves) or [composites](#graphs-leaves). It also allows us to associate them with [handlers](#handlers).

Leaves themselves have no visualization as they have no children.

Here's an example model graph where _main_ is a leaf:
```json
{
  "main": {"type": "leaf"}
}
```

Entry points are totally __ignored__ when the target is a leaf. It's because a leaf cannot have different states.

## Composites
Composites are a way to introduce orthogonal states. If there's a node _A_ and there's a node _B_, we can create a composite _C_ with _A_ and _B_ as underlaying nodes. That way if the model is in the _C_ state, it has both the behavior of _A_ and the behavior of _B_.

This is what a composite with two local nodes (_First composed node_ and _Second composed node_) looks like.

![Composite](img/composite.png)

The code, assuming there are some nodes _A_ and _B_ which are used as underlaying nodes for _First composed node_ and _Second composed node_, looks like this.
```json
{
  // some main
  "A": // some node
  "B": // some node
  "C": {
    "type": "composite",
    "nodes": {
      "First composed node": "A",
      "Second composed node": "B"
    }
  }
}
```

Composites are __transparent for entry points__. Here's an example of how does it work.

There's a graph, where _some node_ follows the _action_ arrow and enter the _p_ entry point of the _composite_.

![arrow to a composite](img/arrow_to_composite_graph.png)

The composite composes two graphs together.

![arrow to a composite](img/arrow_to_composite_composite.png)

_Subgraph A_ has an entry point _p_ which points at node _B_.

![arrow to a composite](img/arrow_to_composite_subgraph_a.png)

_Subgraph B_ has an entry point _p_ which points at node _A_.

![arrow to a composite](img/arrow_to_composite_subgraph_b.png)

In such a situation, the entered __entry point is required to be present in both graph__.

To sum it up, the result of _main:some node_ following the _action_ arrow to enter _composite_ through the entry point _p_ is setting the model to _(main:composite:subgraph A:B, main:composite:subgraph B:A)_.

Composites are __transparent to arrows followed by their children__. If at least one child follows some arrow, the whole composite follows this arrow. If two or more children follow some arrows, the composite follows those few arrows simultaneously.

## Dynamic composites

Dynamic composites are very similar to regular composites with one very important difference - __the list of children nodes is generated using a function of the context__.

Let's take a look at this regular composite.
```json
{
  "main": {
    "type": "composite",
    "nodes": {
      "First": "Child",
      "Second": "Child"
    }
  },
  "Child": {"type": "leaf"}
}
```

The main composite has two chilren: First and Second. They are all leafs defined by the Child node. The number of main's children never changes. 

The same graph structure may be achieved using a dynamic composite.

```json
{
  "main": {
    "type": "dynamicComposite",
    "nodeTemplate": "leaf"
  },
  "Child": {"type": "leaf"}
}
```

The handler of the main node must define a function of the context which returns local names of the children.

```javascript
{
  main: {
    nodes: ({ctx}) => ctx.myChildren
  }
}
```

This dynamic composite associated with the handler visible above results in a graph identical to the regular composite described at the beginning of this section, when the context looks like this.
```javascript
{
  myChildren: ["First", "Second"]
}
```

However, as soon as a transition changes the context, the graph also changes.

Let's say the context looks like this.
```javascript
{
  myChildren: ["First", "Second", "Third"]
}
```

Then the graph equals the following regular composite.
```json
{
  "main": {
    "type": "composite",
    "nodes": {
      "First": "Child",
      "Second": "Child",
      "Third": "Child"
    }
  },
  "Child": {"type": "leaf"}
}
```

What's important to note is that __when a dynamically generated child is removed, its current nodes are forgotten__. So if there were three dynamic children: First, Second and Third and we removed the Second one, the next time it appears it behaves like it never existed.

If you find this helpful, you may also be interested in [context slices](#handlers-context-slices).

## Graphs
Graphs are the most important type of nodes. 
We're going to discuss them using the following example:

![arrow to a composite](img/complex_graph.png)

Here is the generated JSON file:
```json
{
  "some leaf": {
    "type": "leaf"
  },
  "another leaf": {
    "type": "leaf"
  },
  "main": {
    "type": "graph",
    "nodes": {
      "A": "some leaf",
      "B": "another leaf"
    },
    "arrows": {
      "A": {
        "going for a walk": {
          "target": "B",
          "entryPoint": "start"
        },
        "doing a loop": {
          "target": "A",
          "entryPoint": "twisted"
        }
      },
      "B": {
        "going back": {
          "target": "A",
          "entryPoint": "start"
        }
      }
    },
    "entryPoints": {
      "start": {
        "target": "A",
        "entryPoint": "beginning"
      },
      "history": {
        "target": "recent",
        "entryPoint": "going back to the past"
      },
      "back door": {
        "target": "B",
        "entryPoint": "window"
      }
    }
  }
}
```

Graphs are made of:

- at least one local node
- any number of arrows
- the required _start entry point_
- the special _recent node_
- any number custom entry points

At any given time, there's just one active graph node. 

There are two local nodes in the screen-shot above: _A_ and _B_. They must be associated with some actual nodes, like leaves, composites or other graphs. It's done by selecting the _underlaying node_.

Entry points specify which local node is going to be active once a transition to the graph occurs.

Only one entry point is mandatory and it's the _start entry point_. It cannot point at the _recent node_. Except this one, there may be any number of custom entry points.

An arrow from an entry point to a node means that when the graph is entered through that entry point, the active node is going to be the node the arrow is pointing at. The arrow also specify an entry point. In the picture visible above, the _start entry point_ is pointing at the node _A_ and specifies that it should be entered through the "beginning" entry point point. Arrows may be pointing just from entry points and never at entry points. Also, there may be just one arrow from one entry point.

There's one special node and it's the _recent node_. It symbolizes the last node which was active, before the graph was left. If the graph has never been entered, it's the node the _start entry point_ is connected to. 
In the picture above we can see that if the graph is entered through the _history_ entry point, then it's most recent active child is going to be entered through the _going back to the past_ entry point.

Arrows between nodes symbolize how does the behavior change. Here, when the current node is _A_ and it follows the arrow _going for a walk_, it changes the current node of the graph to _B_ which is entered through the _start_ entry point.

Loops are allowed.

All the nodes visible when drawing a graph are local nodes. They are not available outside the graph that's being edited. The actual node, which is entered when a local node is entered, is picked using the _underlaying node_ select field.

If a local node follows an arrow, which is not connected to any other local node, it makes the whole graph follow this arrow. It works very similar to event bubbling.

# Handlers

## Introduction

While the graph is just data representing how does the behavior change, handlers are functions which represent the actual behavior.

Although it's not necessary, all handlers may be made of pure functions, which are actually the preferred choice.

When a model method is called, it's redirected to the appropriate handler picked based upon the state of the state machine. 

Let's assume that the current node is _A_ (which is a leaf) and that this is its handler:
```javascript
const A = {
  myMethod: () => "myMethodResult"
};
```

Then when we call the model in this way:
```javascript
> model.myMethod()
```

The result is gong to be
```
'myMethodResult'
```

It's not required for handlers to handle all types of methods or always return something. __If we call a non-existent method, we simply get undefined as the result__:
```javascript
> model.nonExistentMethod()
undefined
```

However, __arrows must always be successfully followed__. A request to follow an arrow is bubbling up the hierarchy unless one of its ancestors may follow it. If the arrow cannot be followed, an error is thrown.

## Method handlers

Rosmaro models may be called without any parameters or with only one object.
```
> model.myMethod();
> model.myMethod({paramA, paramB});
```
The complete example of a method handler for _myMethod_ looks like this:
```javascript
{
  myMethod: ({paramA, paramB, ctx, thisModel, thisModelNode}) => ({
    arrow: 'arrow to follow',
    ctx: newCtx,
    res: 'method call result'
  })
}
```

As we can see, a method handler takes one object. It contains all the fields which were passed during the model method call (_paramA_ and _paramB_) and few extra ones, which include _ctx_, _thisModel_ and _thisModelNode_. The result of a handler method call may be one of the following forms:
```javascript
// no arrow is followed
// the context is not altered
// the result is undefined
undefined

// 'x' is the arrow to follow
// {a: 123} is the new context
// 'abc' is the call result
{arrow: 'x', ctx: {a: 123}, res: 'abc'}

// 'x' is the arrow to follow
// the context is not altered
// the result is undefined
{arrow: 'x'}

// no arrow is followed
// the context is not altered
// {res: 'freedom'} is the result
{res: {res: 'freedom'}}

// {anything: 'else'} is the call result
{anything: 'else'}
```

_ctx_ is the context of the model. It's a plain old JavaScript object which must be serializable and is passed to all method handlers. This is the dictionary structure where data-related state lives in. It must __never be mutated__. Returning a new version of the context by a method handler is the only way how a change to the context may be introduced. It makes it very __similar to redux__. By default the context is an empty object. 

The most important thing to remember when it comes to the context is how does it behave when composites are used. Let's say that the context looks like this:
```javascript
{a: 10, b: 20}
```
Then we have two composed nodes: _A_ and _B_ and both of them perform a transition by simultaneously following some arrows.

The handler for the _A_ node gets the current context and changes the _a_ field:
```javascript
{a: 10, b: 20} -> {a: 11, b: 20} 
```

The handler for the _B_ node gets the current context and changes the _b_ field:
```javascript
{a: 10, b: 20} -> {a: 10, b: 40} 
```

The result is merged by applying differences between the current node and new versions of the context returned by all composed nodes. It makes the final context look like this:
```javascript
{a: 11, b: 40} 
```

_thisModel_ is a reference to the whole __Rosmaro model__. What's very important is that in order to avoid the model going into an inconsistent state, one method call must finish before another one starts. That's why calling a model method from within a method handler will __always return a Promise__. Awaiting for this promise to resolve within a method handler will __always lead a deadlock__! It happens because a method handler cannot return, as it's waiting for the method call to finish, and the method call doesn't even start executing, because the previous method call (which is currently handled by the handler) hasn't finished yet.

Even thought it may seem to be not so helpful, there are use cases where it turns out to be quite handy. An example may be browser-based user interface, where a handler's _render_ method returns a VDOM node which event listener uses _thisModel_. Here is an example of a [snabbdom](https://github.com/snabbdom/snabbdom) event listener calling a __Rosmaro model__ taken from the code of the [Rosmaro Editor](https://rosmaro.js.org/editor):
```javascript
h('input.ctrl-button', {
  props: {type: 'button', value: 'generate code'},
  on: {click: () => thisModel.generateCode()}
})
```

This works as expected and __never causes a deadlock__.

Moreover, because the _generateCode_ method call happens when the button is clicked and not before the handler returns, the call is fully synchronous if the locking mechanism, storage mechanism and the handler for _generateCode_ are synchronous themselves.

_thisModelNode_ is very similar to _thisModel_. It's also an object which may be used to call Rosmaro model methods. However, only methods defined by the handler that received it and handlers of its children are going to be called.

It means that when there's an active composite with two children and each of them responds to the _myMethod_ method, calling _thisModel.myMethod_ actually calls two methods, while calling _thisNode.myMethod_ from within a child's handler calls only one method.

When it comes to method call results, things are straightforward in case of leaves and graphs. The result is what the method handler returns as the result. However, things get a bit (but just a bit) more complicated when composite nodes are used. Let's take a look at the following composite.

![composite](img/composite.png)

Let's assume it's the _main node_ of a _Rosmaro model_. The underlaying node of the _First composed node_ local node is a leaf _A_, and the underlaying node of the _Second composed node_ local node is a leaf _B_.

Here's the handler of _A_.
```javascript
const A = {
  saySomething: () => "Hello"
};
```

And here's the handler of _B_.
```javascript
const B = {
  saySomething: () => "World"
};
```

If we call the _saySomething__ method of the model, we get the following result:
```
{'First composed node': 'Hello', 'Second composed node': 'World'}
```
It's because both nodes, _A_ and _B_, responded to the call, as they were composed together. What's worth noticing, is that local names of composite children are used instead of _A_ and _B_. It's the only way how it may be warranted that everything is going to be returned, because two different children of a composite may use the same actual node as their underlaying nodes. It also becomes very handy when we want alter the result of a composite.

## Altering results
In the example above the result we got was a map between values actually returned by leaf handlers and local names of composed nodes. However, in most cases a result like this is not what we would like. The desired output could look like this:
```
'Hello World!'
```
In order to achieve this, we will associate a handler with the composite itself. It will alter the result call. The composite is our _main_ node, so let's write a result altering handler.
```javascript
const main = {
  afterSaySomething: ({res}) => 
    res['First composed node'] + ' ' + res['Second composed node'] + '!'
}
```

The method which result we want to alter is called _saySomething_, so the result altering function needs to be placed under the _afterSaySomething_ key. It always follows the pattern of prefixing the method name with _after_ and making the first letter of the method name capital.

The result altering function takes just one argument and it's the original result, what in case of a composite has the following form:
```
{
  'local child name': 'underlaying node result', 
  'another local child name': 'another underlaying node result'
}
```
That's why _"Hello"_ is present under the _First composed node_ key and _"World"_ is present under the _Second composed node_ key.

This technique turns out to be helpful everywhere where the result is build from pieces returned by composed nodes. Here's an example of a part of view being composed out of few smaller parts returned by children of a composite:

```javascript
{
  afterRender: ({res}) => 
    h('div.editor', {}, [
      h('div.main-screen', {}, [
        h('div.node-list', {}, res.nodeList),
        res.graphView
      ]),
      h('div.toolbar', {}, res.toolbar)
    ])
}
```

## Initial context

The context of a freshly created _Rosmaro model_ is an empty object. 

Let's imagine, that a [method handler](#handlers-method-handlers) is supposed to return the name of somebody. The name is, most of the time, stored within the context. And that's the tricky part - it's there just most of the times. At the beginning, when the context is empty, it's not there.

The handler may be implemented like this.
```javascript
const SomeHandler = {
  readName: ({ctx}) => ctx.name || 'Unknown person'
};
```

However, it is an unnecessary conditional statement (_||_), which in the worst scenario may be repeated over and over again. A better way to tackle this is to specify the _initial context_. It is used every time __when the context is empty and only then__.

The same result, without an explicit conditional statement.
```
const SomeHandler = {
  initCtx: {name: 'Unknown person'},
  readName: ({ctx}) => ctx.name
};
```

If you find this helpful, you may also be interested in [context slices](#handlers-context-slices).

## Context slices

The context, by default, is shared among all method handlers. It is a good way to start, because some models may be simple enough to not need any extra separation. However, when the number of nodes grows, and especially when we introduce composites or sub-graphs, it becomes easier to make a mistake and modify some part of the context which wasn't supposed to be modified.

Context slices help to solve this problem by making handlers of some nodes (and handlers of their children) operate on narrow slices of the whole context.

### Object property slices

Let's assume the whole, model-wide context looks like this.
```javascript
{
  personName: 'John',
  pet: {
    name: 'Tom'
  }
}
```

If there's some node that specializes in handling actions related to the pet and doesn't need to access the name of the owner, we can narrow the context down. Now the handler of the _Pet_ node, and handlers of its children (if it's a graph or a composite) will see just a part of the context.
```javascript
const PetNodeHandler = {
  ctxSlice: 'pet',
  method: ({ctx}) {
    // ctx is {name: 'Tom'} 
  }
};
```

Any new context returned by a handler which operates on a slice of the whole context will modify just this slice and leave the rest untouched.

### Local node name based slices

It's the special type of context slices. Instead of specifying a fixes name, it uses the local node name.

Let's say the context looks like this.
```javascript
{
  First: {name: 'Solange'},
  Second: {name: 'Łukasz'}
}
```

The graph has a composite with two children: First and Second.

![A composite with two children: First and Second](img/composite_first_second.png)

Then we can specify that children should get slices of the context based on their local names.

```javascript
const First = {
  ctxSlice: 'localNodeName',
  method: ({ctx}) {
    // ctx is {name: 'Solange'}
  }
};

const Second = {
  ctxSlice: 'localNodeName',
  method: ({ctx}) {
    // ctx is {name: 'Łukasz'}
  }
};
```

This is especially helpful when working with dynamic composites. The local node name may be some type of ID.

If you find this helpful, you may also be interested in [the initial context](#handlers-initial-context).

## Method autorun

When a transition to a different node occurs, __the _run_ method of the whole model is called automatically__.

```javascript
const Choice = {
  run: ({ctx}) => ({
    arrow: ctx.pet === 'cat' ? 'has a cat' : 'has no cat'
  })
}
```

It may cause a transition, which may lead to a state which responds to the _run_ method by causing another transition and so on. It is an elegant way of implementing choice states.

The method call result is always the result of the first method call, without the results of the automatically called _run_ methods.

## Renaming methods

Let's take a look at the following handler.
```javascript
const ActiveNode = {
  a: () => 'the result of a()'
};
```

Calling _model.a()_ gives us _the result of a()_.

We can specify a way how method names change.

```javascript
const ActiveNode = {
  methodMap: {
    x: 'a'
  },
  a: () => 'the result of a()'
};
```

Thanks to this change we can call _model.x()_ and still get _the result of a()_.

# Building a model

## Introduction

The graph is just pure, immutable data.

The handlers are (preferably) just pure functions.

Building a _Rosmaro model_ is how we put them together.

The built model redirects method calls to appropriate handlers based upon the current node of the graph. The current graph node and context of the model are stored using a storage mechanism we provide. Method calls may also be synchronized using some provided locking mechanism.

The Rosmaro factory function comes from the [rosmaro package](https://www.npmjs.com/package/rosmaro).
```no-highlight
$ npm i rosmaro --save
```

Below is an example of how we call it.
```javascript
import rosmaro from 'rosmaro';

const model = rosmaro({
  graph,
  handlers,
  storage,
  lock,
  afterTransition
});
```

## Graph

The __graph__ parameter is a parsed JSON file generated using the [Rosmaro Editor](https://rosmaro.js.org/editor). It should have the following format:
```javascript
const graph = {
  'main': {type, /* ... */},
  'another node': {type, /* ... */},
  'yet another node': {type, /* ... */},
  /* ... */
};
```
What's important to node is that what the Rosmaro factory expects is actually a plain old JavaScript object.
Let's assume the graph is stored in a file called _graph.json_. Then we load it like this:
```javascript
import graph from './graph.json'
```

## Handlers

_handlers_ reflect the structure of the _graph_. For example, if we wanted to associate two handlers, we would do it like this:
```javascript
const handlers = {
  'another node': {/* ... */},
  'yet another node': {/* ... */},
};
```

## Storage

The _storage_ is an object with the following signature.
```javascript
const storage = {
  get: () => data,
  set: newData => undefined
};
```

Calling the _get_ method returns what was set using the _set_ method. It may return the result immediately or __return a Promise which__ resolves to it. If nothing has been set, it returns _undefined_.

The _set_ method takes some object and stores it. It may return immediately or __return a Promise__ which resolves to undefined. If it's called with any falsy value, it's meant to remove previously stored data.

Both _get_ and _set_ may throw errors, but those __errors must be Error objects__. Otherwise they cannot be handled correctly.

Here's a list of recommended storage mechanisms.
Name | Description | Url
--- | --- | ---
rosmaro-in-memory-storage | In-memory storage. | [github.com/lukaszmakuch/rosmaro-in-memory-storage](https://github.com/lukaszmakuch/rosmaro-in-memory-storage)
If you know a compatible storage which is not mentioned above, let me know and it'll be included! :)

## Lock

The _lock_ is a function with the following signature.
```javascript
const lock = () => unlock;
```

Calling the _lock_ function gives us the _unlock_ function. It may return it immediately or __return a Promise__ which resolves to it. 

Getting the _unlock_ function means that a lock has been acquired. It's not possible to get another _unlock_ function unless the previously obtained _unlock_ function is called.

Calling the _unlock_ function returns _undefined_ or _a Promise_ which if resolved indicates that the previously acquired lock has been released.

Both _lock_ and _unlock_ may throw errors, but those __errors must be Error objects__. Otherwise they cannot be handled correctly.

A locking mechanism may be very useful, especially when the storage or some method handler is asynchronous, in order to prevent the model from going into inconsistent state.

Name | Description | Url
--- | --- | ---
rosmaro-process-wide-lock | Process-wide, in-memory lock. | [github.com/lukaszmakuch/rosmaro-process-wide-lock](https://github.com/lukaszmakuch/rosmaro-process-wide-lock)

If you know a compatible locking mechanism which is not mentioned above, let me know and it'll be included! :)

## Transition listener

_afterTransition_ is a listener function that takes no arguments and is executed after every transition. It is executed exactly after the the method call is handled, the state is updated and the lock is released and before the method call result is returned.

# Special methods

Below is a list of special methods which don't originate from [method handlers](#handlers).

You may also be interested in [lifecycle hooks](#handlers-lifecycle-hooks).

## .remove()

The _remove_ method is the way to safely remove a _Rosmaro model_. 

It does the following things:

1. acquires a lock
2. removes stored model data (by calling _storage.set(undefined)_)
3. calls _afterLeft_ [lifecycle hooks](#handlers-lifecycle-hooks) of all nodes, __including _main___
4. releases the lock

In most cases, especially when the model is eternal or can be safely garbage collected together with all of its dependencies, it's not necessary to use it.

However, in some cases it may be useful. For example, when the state of the model shouldn't stay forever in the application database and if some side effects are required to remove some external resources as well. 

# Error handling

When developing method handlers, we should do our best to _avoid uncaught errors_ (or rejected Promises).

However, sometimes errors may be thrown due to reasons we cannot fully control. This requires special attention especially when Rosmaro is used to model the behavior of some back-end services, as errors there may affect many users.

What's crucial in order to make error handling successful, is to __always throw Error objects__. Otherwise Rosmaro cannot handle errors correctly. Keeping this in mind, let's dig a bit deeper into this.

Basically, there are few moments of handling a method call when errors may occur:
1. acquiring the lock
2. reading from the storage
3. handling the method call
4. writing to the storage
5. releasing the lock

The most dangerous scenario is when a lock is acquired but never released.

Rosmaro does its best to avoid such a situation by calling _unlock_ even if an error is thrown (or a Promise is rejected) in any of the following steps:

2. reading from the storage
3. handling the method call
4. writing to the storage

If an error occurs, the lock is released and the error that caused the failure is thrown. That way a _Rosmaro model_ is transparent to errors.

But there's another case, which is a bit more problematic. It happens when two errors are thrown. One within one of the following steps:

2. reading from the storage
3. handling the method call
4. writing to the storage

And one when calling the _unlock_ method. What makes this case complicated is that there are two reasons why did the method call failed:

- handling the call itself failed (error 1)
- unlocking in emergency mode failed (error 2)

The error which is finally thrown is _error 2_ with an extra _previous_ property set to _error 1_. That's why it's important to __always throw Error objects__, because otherwise it may be not possible to set the _previous_ property.

  </script>
</head>
<body role='flatdoc' class='big-h3 no-literate'>

  <div class='header'>
    <div class='left'>
      <h1>Rosmaro</h1>
      <ul>
        <li><a href='https://github.com/lukaszmakuch/rosmaro'>View on GitHub</a></li>
      </ul>
    </div>
    <div class='right'>
      <!-- GitHub buttons: see http://ghbtns.com -->
      <iframe src="http://ghbtns.com/github-btn.html?user=lukaszmakuch&amp;repo=rosmaro&amp;type=watch&amp;count=true" allowtransparency="true" frameborder="0" scrolling="0" width="110" height="20"></iframe>
    </div>
  </div>

  <div class='content-root'>
    <div class='menubar'>
      <img src="img/logo.png" class="logo"/>
      <div class='menu section' role='flatdoc-menu'></div>
    </div>
    <div role='flatdoc-content' class='content'></div>
  </div>

</body>
</html>
