<!doctype html>
<html>
<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width">

  <title>Rosmaro - visual automata-based programming</title>

  <!-- Flatdoc -->
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script src='https://cdn.rawgit.com/rstacruz/flatdoc/v0.9.0/legacy.js'></script>
  <script src='https://cdn.rawgit.com/rstacruz/flatdoc/v0.9.0/flatdoc.js'></script>

  <!-- Flatdoc theme -->
  <link  href='https://cdn.rawgit.com/rstacruz/flatdoc/v0.9.0/theme-white/style.css' rel='stylesheet'>
  <script src='https://cdn.rawgit.com/rstacruz/flatdoc/v0.9.0/theme-white/script.js'></script>

  <!-- custom css -->
  <link  href='style.css' rel='stylesheet'>

  <!-- Meta -->
  <meta content="Rosmaro" property="og:title">
  <meta content="A visual automata-based programming library for JavaScript." name="description">

  <!-- Initializer -->
  <script>
    Flatdoc.run({
      fetcher: function (callback) {
        callback(null, document.getElementById('doc').innerHTML)
      }
    });
  </script>

  <script id="doc" type="text/markdown" src="index.html">
# Rosmaro 101

## What is Rosmaro

Rosmaro is a visual automata-based programming library for JavaScript. 

It allows to build stateful objects - _Rosmaro models_. They keep data-related state in a dictionary structure and express behavior-related state using a state machine.

If you wish, you can think of Rosmaro using one of the following metaphors:

- An event-based routing for methods
- An object where _this_ is a state machine 
- A flavor of state diagrams brought to life

## What makes Rosmaro interesting

There are at least few reasons why Rosmaro may be interesting:

- Reduced number of error-prone conditional statements achieved by replacing many boolean flags with a graph.
- Programing using a human-friendly, declarative visual language that says _what_ should happen and not _how_ should it happen. 
- Code decoupling - any particular handler has a constant behavior that never changes and is not directly connected to any other handler.

## Example

Building a _Rosmaro model_ consist of two steps: 

1. Drawing a state machine graph that describes changes of behavior
1. Coding handlers - pieces of behavior associated with graph nodes

Let's build a model of a cursed prince, who turns into a frog after eating a pizza.

Although we could write a JSON file describing the graph by hand, it's a lot more fun to use the [Rosmaro Editor](https://rosmaro.js.org/editor).

![model graph](img/example-graph.png "A cursed prince")

After drawing the graph visible above, __the following JSON is generated automatically__.
```json
{
  "main": {
    "type": "graph",
    "nodes": {
      "Prince": "Prince",
      "Frog": "Frog"
    },
    "arrows": {
      "Prince": {
        "ate pizza": {
          "target": "Frog",
          "entryPoint": "start"
        }
      }
    },
    "entryPoints": {
      "start": {
        "target": "Prince",
        "entryPoint": "start"
      }
    }
  },
  "Prince": {
    "type": "leaf"
  },
  "Frog": {
    "type": "leaf"
  }
}
```

The graph tells the story of how does the model change over time and what makes it change. At the beginning it behaves like a _Prince_. That's what the arrow from the _start_ entry point pointing at the _Prince_ node is telling us. Then, as soon as the _Prince_ eats a pizza, he follows the arrow called _ate pizza_. The model is not anymore in the _Prince_ state, but in the _Frog_ state.

Now it's the time to code different behaviors.

This is the behavior of the _Frog_:
```javascript
const Frog = {
  introduceYourself: () => "Ribbit! Ribbit!"
};
```

It answers to only one method call - _introduceYourself_. Every single time when it's asked to introduce itself, it makes the _Ribbit!_ sound.

This is the behavior of the _Prince_:
```javascript
const Prince = {
  introduceYourself: () => "I am The Prince of Rosmaro!",
  eat: ({dish}) => {
    if (dish === 'pizza') return {arrow: 'ate pizza'};
  }
};
```

Every time he introduce himself, he says _I am The Prince of Rosmaro!_. When he eats a pizza, he follows the _ate pizza_ arrow.

Let's put it all together.
```javascript
import makeStorage from 'rosmaro-in-memory-storage';
import makeLock from 'rosmaro-process-wide-lock';
import rosmaro from 'rosmaro';
import graph from './graph.json'; // The generated graph

const Frog = {
  introduceYourself: () => "Ribbit! Ribbit!"
};

const Prince = {
  introduceYourself: () => "I am The Prince of Rosmaro!",
  eat: ({dish}) => {
    if (dish === 'pizza') return {arrow: 'ate pizza'};
  }
};

const model = rosmaro({
  graph,
  handlers: {Prince, Frog},
  storage: makeStorage(),
  lock: makeLock()
});
```

In order to obtain a working model, we need to provide at least 4 parts:

- the state machine graph (generated based on the drawn graph)
- handlers (code representing different behaviors)
- a storage (for example, from the _rosmaro-in-memory-storage_ package)
- a lock (for example, from the _rosmaro-process-wide-lock_ package)

The model works like expected:
```javascript
> model.introduceYourself();
'I am The Prince of Rosmaro!'

> model.eat({dish: 'yakisoba'});
undefined

> model.introduceYourself();
'I am The Prince of Rosmaro!'

> model.eat({dish: 'pizza'});
undefined

> model.introduceYourself();
'Ribbit! Ribbit!'
```

## License
Rosmaro is licensed under the MIT license.

# Graphs

## Introduction

The graph is the most outer layer of a _Rosmaro model_. It is meant to represent all of the possible changes of behavior. 

There are three types of nodes:

- leaves
- composites
- graphs

The model graph is represented by a collection of nodes, where each node has a unique name. The root node of the model graph is __the _main_ node, which is mandatory__. It may be of any of the supported node types, even a leaf.

Let's take a look at [the example graph](#rosmaro-101-example) one more time. It's a collection of three nodes:

- a graph called _main_
- a leaf called _Prince_
- a leaf called _Frog_

What's important and what's going to be explained in details later in this chapter, is that local names of nodes of a graph are not directly connected to any node. It means that the _Prince_ local node within the _main_ graph could be renamed to _Human_ and still be linked to the _Prince_ node.

The structure used to build the model graph looks like this:

1. Node A
  1. Local node A (underlaying node: Node B)
  1. Local node B (underlaying node: Node C)
1. Node B
1. Node C
  1. Local node A (underlaying node: Node D)
1. Node D

## The Rosmaro Editor

The recommended way of drawing a graph is using the [Rosmaro Editor](https://rosmaro.js.org/editor). To get started you don't need to install anything, as it is available on-line. A new graph may be created, or an existing JSON file may be imported.

However, if you only want, you actually code parts of the graph or even the whole graph, as the JSON file generated by the editor is meant to be human-readable.

## Leaves

Leaves are the basic nodes. They have no children. All they have is a name, so they can be used as underlaying nodes for children of [graphs](#graphs-leaves) or [composites](#graphs-leaves). It also allows us to associate them with [handlers](#handlers).

Leaves themselves have no visualization as they have no children.

Here's an example model graph where _main_ is a leaf:
```json
{
  "main": {"type": "leaf"}
}
```

Entry points are totally __ignored__ when the target is a leaf. It's because a leaf cannot have different states.

## Composites
Composites are a way to introduce orthogonal states. If there's a node _A_ and there's a node _B_, we can create a composite _C_ with _A_ and _B_ as underlaying nodes. That way if the model is in the _C_ state, it has both the behavior of _A_ and the behavior of _B_.

This is what a composite with two local nodes (_First composed node_ and _Second composed node_) looks like.

![Composite](img/composite.png)

The code, assuming there are some nodes _A_ and _B_ which are used as underlaying nodes for _First composed node_ and _Second composed node_, looks like this.
```json
{
  // some main
  "A": // some node
  "B": // some node
  "C": {
    "type": "composite",
    "nodes": {
      "First composed node": "A",
      "Second composed node": "B"
    }
  }
}
```

Composites are __transparent for entry points__. Here's an example of how does it work.

There's a graph, where _some node_ follows the _action_ arrow and enter the _p_ entry point of the _composite_.

![arrow to a composite](img/arrow_to_composite_graph.png)

The composite composes two graphs together.

![arrow to a composite](img/arrow_to_composite_composite.png)

_Subgraph A_ has an entry point _p_ which points at node _B_.

![arrow to a composite](img/arrow_to_composite_subgraph_a.png)

_Subgraph B_ has an entry point _p_ which points at node _A_.

![arrow to a composite](img/arrow_to_composite_subgraph_b.png)

In such a situation, the entered __entry point is required to be present in both graph__.

To sum it up, the result of _main:some node_ following the _action_ arrow to enter _composite_ through the entry point _p_ is setting the model to _(main:composite:subgraph A:B, main:composite:subgraph B:A)_.

Composites are __transparent to arrows followed by their children__. If at least one child follows some arrow, the whole composite follows this arrow. If two or more children follow some arrows, the composite follows those few arrows simultaneously.

## Graphs
Graphs are the most important type of nodes. 
We're going to discuss them using the following example:

![arrow to a composite](img/complex_graph.png)

Here is the generated JSON file:
```json
{
  "some leaf": {
    "type": "leaf"
  },
  "another leaf": {
    "type": "leaf"
  },
  "main": {
    "type": "graph",
    "nodes": {
      "A": "some leaf",
      "B": "another leaf"
    },
    "arrows": {
      "A": {
        "going for a walk": {
          "target": "B",
          "entryPoint": "start"
        },
        "doing a loop": {
          "target": "A",
          "entryPoint": "twisted"
        }
      },
      "B": {
        "going back": {
          "target": "A",
          "entryPoint": "start"
        }
      }
    },
    "entryPoints": {
      "start": {
        "target": "A",
        "entryPoint": "beginning"
      },
      "history": {
        "target": "recent",
        "entryPoint": "going back to the past"
      },
      "back door": {
        "target": "B",
        "entryPoint": "window"
      }
    }
  }
}
```

Graphs are made of:

- at least one local node
- any number of arrows
- the required _start entry point_
- the special _recent node_
- any number custom entry points

At any given time, there's just one active graph node. 

There are two local nodes in the screen-shot above: _A_ and _B_. They must be associated with some actual nodes, like leaves, composites or other graphs. It's done by selecting the _underlaying node_.

Entry points specify which local node is going to be active once a transition to the graph occurs.

Only one entry point is mandatory and it's the _start entry point_. It cannot point at the _recent node_. Except this one, there may be any number of custom entry points.

An arrow from an entry point to a node means that when the graph is entered through that entry point, the active node is going to be the node the arrow is pointing at. The arrow also specify an entry point. In the picture visible above, the _start entry point_ is pointing at the node _A_ and specifies that it should be entered through the "beginning" entry point point. Arrows may be pointing just from entry points and never at entry points. Also, there may be just one arrow from one entry point.

There's one special node and it's the _recent node_. It symbolizes the last node which was active, before the graph was left. If the graph has never been entered, it's the node the _start entry point_ is connected to. 
In the picture above we can see that if the graph is entered through the _history_ entry point, then it's most recent active child is going to be entered through the _going back to the past_ entry point.

Arrows between nodes symbolize how does the behavior change. Here, when the current node is _A_ and it follows the arrow _going for a walk_, it changes the current node of the graph to _B_ which is entered through the _start_ entry point.

Loops are allowed.

All the nodes visible when drawing a graph are local nodes. They are not available outside the graph that's being edited. The actual node, which is entered when a local node is entered, is picked using the _underlaying node_ select field.

If a local node follows an arrow, which is not connected to any other local node, it makes the whole graph follow this arrow. It works very similar to event bubbling.

# Handlers

Although it's not necessary, all handlers may be made of pure functions, which are actually the preferred choice.

TODO:

- after transition listener (when exactly)
- onEntry when and when not, in what order
- afterLeft when and when not, in what order
- afterMethod
- arrows to follow
- leaves
- composites
- thisModel
- mapping arrows
- node.ID
- node.instanceID
- context
- context and composites
- handlers for non-leaves, like composites and whole graphs
- composite results

# Building a model

Building a _Rosmaro model_ is how we put a graph and its handlers together.

TODO

- recommended locking mechanisms
- what are locking mechanisms
- why locking may be desired
- recommended storage mechanisms
- what are storage mechanisms
- storage specification
- lock specification



# TODO not sure
- examples of correct transitions
- examples of incorrect transitions


# TODO Error handling
- what if a method call crashes? automatic unlock
- what if unlock crashes?
- what if both method call and unlock crash?

# TODO rosmaro elsewhere


  </script>
</head>
<body role='flatdoc' class='big-h3 no-literate'>

  <div class='header'>
    <div class='left'>
      <h1>Rosmaro</h1>
      <ul>
        <li><a href='https://github.com/lukaszmakuch/rosmaro'>View on GitHub</a></li>
      </ul>
    </div>
    <div class='right'>
      <!-- GitHub buttons: see http://ghbtns.com -->
      <iframe src="http://ghbtns.com/github-btn.html?user=lukaszmakuch&amp;repo=rosmaro&amp;type=watch&amp;count=true" allowtransparency="true" frameborder="0" scrolling="0" width="110" height="20"></iframe>
    </div>
  </div>

  <div class='content-root'>
    <div class='menubar'>
      <img src="img/logo.png" class="logo"/>
      <div class='menu section' role='flatdoc-menu'></div>
    </div>
    <div role='flatdoc-content' class='content'></div>
  </div>

</body>
</html>
